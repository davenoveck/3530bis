<!-- Copyright (C) The IETF Trust (2007-2008) -->
<!-- Copyright (C) The Internet Society (2006) -->
<section anchor="sec:file_attributes" title="File Attributes">

  <t>
    To meet the requirements of extensibility and increased
    interoperability with non-UNIX platforms, attributes must be
    handled in a flexible manner.  The NFS version 3 fattr3 structure
    contains a fixed list of attributes that not all clients and
    servers are able to support or care about.  The fattr3 structure
    can not be extended as new needs arise and it provides no way
    to indicate non-support.  With the NFS version 4 protocol, the
    client is able query what attributes the server supports and
    construct requests with only those supported attributes (or a
    subset thereof).
  </t>

  <t>
    To this end, attributes are divided into three groups: mandatory,
    recommended, and named.  Both mandatory and recommended attributes
    are supported in the NFS version 4 protocol by a specific and well-
    defined encoding and are identified by number.  They are requested
    by setting a bit in the bit vector sent in the GETATTR request;
    the server response includes a bit vector to list what attributes
    were returned in the response.  New mandatory or recommended
    attributes may be added to the NFS protocol between major revisions
    by publishing a standards-track RFC which allocates a new attribute
    number value and defines the encoding for the attribute.  See 
    <xref target="sec:minor" /> "Minor Versioning" for further discussion.
  </t>

  <t>
    Named attributes are accessed by the new OPENATTR operation,
    which accesses a hidden directory of attributes associated
    with a file system object.  OPENATTR takes a filehandle for the
    object and returns the filehandle for the attribute hierarchy.
    The filehandle for the named attributes is a directory object
    accessible by LOOKUP or READDIR and contains files whose names
    represent the named attributes and whose data bytes are the value
    of the attribute.  For example:

    <figure>
      <artwork>
LOOKUP     "foo"       ; look up file
GETATTR    attrbits
OPENATTR               ; access foo's named attributes
LOOKUP     "x11icon"   ; look up specific attribute
READ       0,4096      ; read stream of bytes
      </artwork>
    </figure>
  </t>

  <t>
    Named attributes are intended for data needed by applications
    rather than by an NFS client implementation.  NFS implementors are
    strongly encouraged to define their new attributes as recommended
    attributes by bringing them to the IETF standards-track process.
  </t>

  <t>
    The set of attributes which are classified as mandatory is
    deliberately small since servers must do whatever it takes to
    support them.  A server should support as many of the recommended
    attributes as possible but by their definition, the server is not
    required to support all of them.  Attributes are deemed mandatory
    if the data is both needed by a large number of clients and is
    not otherwise reasonably computable by the client when support
    is not provided on the server.
  </t>

  <t>
    Note that the hidden directory returned by OPENATTR is a
    convenience for protocol processing.  The client should not
    make any assumptions about the server's implementation of named
    attributes and whether the underlying filesystem at the server has
    a named attribute directory or not.  Therefore, operations such as
    SETATTR and GETATTR on the named attribute directory are undefined.
  </t>

  <section title="Mandatory Attributes">

    <t>
      These MUST be supported by every NFS version 4 client and
      server in order to ensure a minimum level of interoperability.
      The server must store and return these attributes and the
      client must be able to function with an attribute set limited
      to these attributes.  With just the mandatory attributes some
      client functionality may be impaired or limited in some ways.
      A client may ask for any of these attributes to be returned by
      setting a bit in the GETATTR request and the server must return
      their value.
    </t>

  </section>
  <section title="Recommended Attributes">

    <t>
      These attributes are understood well enough to warrant support in
      the NFS version 4 protocol.  However, they may not be supported
      on all clients and servers.  A client may ask for any of these
      attributes to be returned by setting a bit in the GETATTR request
      but must handle the case where the server does not return them.
      A client may ask for the set of attributes the server supports
      and should not request attributes the server does not support.
      A server should be tolerant of requests for unsupported
      attributes and simply not return them rather than considering
      the request an error.  It is expected that servers will support
      all attributes they comfortably can and only fail to support
      attributes which are difficult to support in their operating
      environments.  A server should provide attributes whenever
      they don't have to "tell lies" to the client.  For example,
      a file modification time should be either an accurate time or
      should not be supported by the server.  This will not always
      be comfortable to clients but the client is better positioned
      decide whether and how to fabricate or construct an attribute
      or whether to do without the attribute.
    </t>

  </section>
  <section title="Named Attributes">

    <t>
      These attributes are not supported by direct encoding in the NFS
      Version 4 protocol but are accessed by string names rather than
      numbers and correspond to an uninterpreted stream of bytes which
      are stored with the filesystem object.  The name space for these
      attributes may be accessed by using the OPENATTR operation.
      The OPENATTR operation returns a filehandle for a virtual
      "attribute directory" and further perusal of the name space may
      be done using READDIR and LOOKUP operations on this filehandle.
      Named attributes may then be examined or changed by normal READ
      and WRITE and CREATE operations on the filehandles returned
      from READDIR and LOOKUP.  Named attributes may have attributes.
    </t>

    <t>
      It is recommended that servers support arbitrary named
      attributes.  A client should not depend on the ability to store
      any named attributes in the server's filesystem.  If a server
      does support named attributes, a client which is also able to
      handle them should be able to copy a file's data and meta-data
      with complete transparency from one location to another; this
      would imply that names allowed for regular directory entries
      are valid for named attribute names as well.
    </t>

    <t>
      Names of attributes will not be controlled by this document or
      other IETF standards track documents.  See 
      <xref target="sec:iana" /> "IANA Considerations" for further discussion.
    </t>

  </section>
  <section title="Classification of Attributes">

    <t>
      Each of the Mandatory and Recommended attributes can
      be classified in one of three categories: per server,
      per filesystem, or per filesystem object.  Note that it is
      possible that some per filesystem attributes may vary within the
      filesystem.  See the "homogeneous" attribute for its definition.
      Note that the attributes time_access_set and time_modify_set
      are not listed in this section because they are write-only
      attributes corresponding to time_access and time_modify, and
      are used in a special instance of SETATTR.

      <list style='symbols'>
        <t>
          The per server attribute is:
        <vspace blankLines='1' />
          lease_time
        </t>

        <t>
          The per filesystem attributes are:
        <vspace blankLines='1' />
          supp_attr, fh_expire_type, link_support, symlink_support,
          unique_handles, aclsupport, cansettime, case_insensitive,
          case_preserving, chown_restricted, files_avail, files_free,
          files_total, fs_locations, homogeneous, maxfilesize, maxname,
          maxread, maxwrite, no_trunc, space_avail, space_free,
          space_total, time_delta
        </t>

        <t>
          The per filesystem object attributes are:
        <vspace blankLines='1' />
          type, change, size, named_attr, fsid, rdattr_error,
          filehandle, ACL, archive, fileid, hidden, maxlink, mimetype,
          mode, numlinks, owner, owner_group, rawdev, space_used,
          system, time_access, time_backup, time_create, time_metadata,
          time_modify, mounted_on_fileid
        </t>
      </list>
    </t>

    <t>
      For quota_avail_hard, quota_avail_soft, and quota_used see
      their definitions below for the appropriate classification.
    </t>

  </section>
  <section title="Mandatory Attributes - Definitions">

    <texttable anchor="mand_attr_table">
      <ttcol align='left' >Name</ttcol>
      <ttcol align='left' >Id</ttcol>
      <ttcol align='left' >Data Type</ttcol>
      <ttcol align='left' >Access</ttcol>
      <ttcol align='left' >Description</ttcol>

      <c>supp_attr</c>
      <c>0</c>
      <c>bitmap</c>
      <c>READ</c>
      <c>
        The bit vector which would retrieve all mandatory and
        recommended attributes that are supported for this object.
        The scope of this attribute applies to all objects with a
        matching fsid.
      </c>

      <c>type</c>
      <c>1</c>
      <c>nfs4_ftype</c>
      <c>READ</c>
      <c>
        The type of the object (file, directory, symlink, etc.)
      </c>

      <c>fh_expire_type</c>
      <c>2</c>
      <c>uint32</c>
      <c>READ</c>
      <c>
        Server uses this to specify filehandle expiration behavior
        to the client.  See <xref target="sec:filehandles" />
        "Filehandles" for additional description.
      </c>

      <c>change</c>
      <c>3</c>
      <c>uint64</c>
      <c>READ</c>
      <c>
        A value created by the server that the client can use to
        determine if file data, directory contents or attributes of
        the object have been modified.  The server may return the
        object's time_metadata attribute for this attribute's value
        but only if the filesystem object can not be updated more
        frequently than the resolution of time_metadata.
      </c>

      <c>size</c>
      <c>4</c>
      <c>uint64</c>
      <c>R/W</c>
      <c>
        The size of the object in bytes.
      </c>

      <c>link_support</c>
      <c>5</c>
      <c>bool</c>
      <c>READ</c>
      <c>
        True, if the object's filesystem supports hard links.
      </c>

      <c>symlink_support</c>
      <c>6</c>
      <c>bool</c>
      <c>READ</c>
      <c>
        True, if the object's filesystem supports symbolic links.
      </c>

      <c>named_attr</c>
      <c>7</c>
      <c>bool</c>
      <c>READ</c>
      <c>
        True, if this object has named attributes.  In other words,
        object has a non-empty named attribute directory.
      </c>

      <c>fsid</c>
      <c>8</c>
      <c>fsid4</c>
      <c>READ</c>
      <c>
        Unique filesystem identifier for the filesystem holding
        this object.  fsid contains major and minor components each
        of which are uint64.
      </c>

      <c>unique_handles</c>
      <c>9</c>
      <c>bool</c>
      <c>READ</c>
      <c>
        True, if two distinct filehandles are guaranteed to refer to two
        different filesystem objects.
      </c>

      <c>lease_time</c>
      <c>10</c>
      <c>nfs_lease4</c>
      <c>READ</c>
      <c>
        Duration of leases at server in seconds.
      </c>

      <c>rdattr_error</c>
      <c>11</c>
      <c>enum</c>
      <c>READ</c>
      <c>
        Error returned from getattr during readdir.
      </c>

      <c>filehandle</c>
      <c>19</c>
      <c>nfs_fh4</c>
      <c>READ</c>
      <c>
        The filehandle of this object (primarily for readdir requests).
      </c>
    </texttable>

  </section>
  <section title="Recommended Attributes - Definitions">

    <texttable anchor="recommended_attr_table">
      <ttcol align='left' >Name</ttcol>
      <ttcol align='left' >Id</ttcol>
      <ttcol align='left' >Data Type</ttcol>
      <ttcol align='left' >Access</ttcol>
      <ttcol align='left' >Description</ttcol>

      <c>ACL</c>
      <c>12</c>
      <c>nfsace4<></c>
      <c>R/W</c>
      <c>
        The access control list for the object.
      </c>

      <c>aclsupport</c>
      <c>13</c>
      <c>uint32</c>
      <c>READ</c>
      <c>
        Indicates what types of ACLs are supported on the current
        filesystem.
      </c>

      <c>archive</c>
      <c>14</c>
      <c>bool</c>
      <c>R/W</c>
      <c>
        True, if this file has been archived since the time of last
        modification (deprecated in favor of time_backup).
      </c>

      <c>cansettime</c>
      <c>15</c>
      <c>bool</c>
      <c>READ</c>
      <c>
        True, if the server is able to change the times for a
        filesystem object as specified in a SETATTR operation.
      </c>

      <c>case_insensitive</c>
      <c>16</c>
      <c>bool</c>
      <c>READ</c>
      <c>
        True, if filename comparisons on this filesystem are case
        insensitive.
      </c>

      <c>case_preserving</c>
      <c>17</c>
      <c>bool</c>
      <c>READ</c>
      <c>
        True, if filename case on this filesystem are preserved.
      </c>

      <c>chown_restricted</c>
      <c>18</c>
      <c>bool</c>
      <c>READ</c>
      <c>
        If TRUE, the server will reject any request to change
        either the owner or the group associated with a file if the
        caller is not a privileged user (for example, "root" in UNIX
        operating environments or in Windows 2000 the "Take Ownership"
        privilege).
      </c>

      <c>fileid</c>
      <c>20</c>
      <c>uint64</c>
      <c>READ</c>
      <c>
        A number uniquely identifying the file within the filesystem.
      </c>

      <c>files_avail</c>
      <c>21</c>
      <c>uint64</c>
      <c>READ</c>
      <c>
        File slots available to this user on the filesystem containing
        this object - this should be the smallest relevant limit.
      </c>

      <c>files_free</c>
      <c>22</c>
      <c>uint64</c>
      <c>READ</c>
      <c>
        Free file slots on the filesystem containing this object -
        this should be the smallest relevant limit.
      </c>

      <c>files_total</c>
      <c>23</c>
      <c>uint64</c>
      <c>READ</c>
      <c>
        Total file slots on the filesystem containing this object.
      </c>

      <c>fs_locations</c>
      <c>24</c>
      <c>fs_locations</c>
      <c>READ</c>
      <c>
        Locations where this filesystem may be found.  If the server
        returns NFS4ERR_MOVED as an error, this attribute MUST be
        supported.
      </c>

      <c>hidden</c>
      <c>25</c>
      <c>bool</c>
      <c>R/W</c>
      <c>
        True, if the file is considered hidden with respect to the
        Windows API.
      </c>

      <c>homogeneous</c>
      <c>26</c>
      <c>bool</c>
      <c>READ</c>
      <c>
        True, if this object's filesystem is homogeneous, i.e., are per
        filesystem attributes the same for all filesystem's objects?
      </c>

      <c>maxfilesize</c>
      <c>27</c>
      <c>uint64</c>
      <c>READ</c>
      <c>
        Maximum supported file size for the filesystem of this object.
      </c>

      <c>maxlink</c>
      <c>28</c>
      <c>uint32</c>
      <c>READ</c>
      <c>
        Maximum number of links for this object.
      </c>

      <c>maxname</c>
      <c>29</c>
      <c>uint32</c>
      <c>READ</c>
      <c>
        Maximum filename size supported for this object.
      </c>

      <c>maxread</c>
      <c>30</c>
      <c>uint64</c>
      <c>READ</c>
      <c>
        Maximum read size supported for this object.
      </c>

      <c>maxwrite</c>
      <c>31</c>
      <c>uint64</c>
      <c>READ</c>
      <c>
        Maximum write size supported for this object.  This attribute
        SHOULD be supported if the file is writable.  Lack of this
        attribute can lead to the client either wasting bandwidth or
        not receiving the best performance.
      </c>

      <c>mimetype</c>
      <c>32</c>
      <c>utf8<></c>
      <c>R/W</c>
      <c>
        MIME body type/subtype of this object.
      </c>

      <c>mode</c>
      <c>33</c>
      <c>mode4</c>
      <c>R/W</c>
      <c>
        UNIX-style mode and permission bits for this object.
      </c>

      <c>no_trunc</c>
      <c>34</c>
      <c>bool</c>
      <c>READ</c>
      <c>
        True, if a name longer than name_max is used, an error be
        returned and name is not truncated.
      </c>

      <c>numlinks</c>
      <c>35</c>
      <c>uint32</c>
      <c>READ</c>
      <c>
        Number of hard links to this object.
      </c>

      <c>owner</c>
      <c>36</c>
      <c>utf8<></c>
      <c>R/W</c>
      <c>
        The string name of the owner of this object.
      </c>

      <c>owner_group</c>
      <c>37</c>
      <c>utf8<></c>
      <c>R/W</c>
      <c>
        The string name of the group ownership of this object.
      </c>

      <c>quota_avail_hard</c>
      <c>38</c>
      <c>uint64</c>
      <c>READ</c>
      <c>
        For definition see <xref target="ss:at:qa" /> "Quota Attributes" below.
      </c>

      <c>quota_avail_soft</c>
      <c>39</c>
      <c>uint64</c>
      <c>READ</c>
      <c>
        For definition see <xref target="ss:at:qa" /> "Quota Attributes" below.
      </c>

      <c>quota_used</c>
      <c>40</c>
      <c>uint64</c>
      <c>READ</c>
      <c>
        For definition see <xref target="ss:at:qa" /> "Quota Attributes" below.
      </c>

      <c>rawdev</c>
      <c>41</c>
      <c>specdata4</c>
      <c>READ</c>
      <c>
        Raw device identifier.  UNIX device major/minor node
        information.  If the value of type is not NF4BLK or NF4CHR,
        the value returned SHOULD NOT be considered useful.
      </c>

      <c>space_avail</c>
      <c>42</c>
      <c>uint64</c>
      <c>READ</c>
      <c>
        Disk space in bytes available to this user on the filesystem
        containing this object - this should be the smallest relevant
        limit.
      </c>

      <c>space_free</c>
      <c>43</c>
      <c>uint64</c>
      <c>READ</c>
      <c>
        Free disk space in bytes on the filesystem containing this
        object - this should be the smallest relevant limit.
      </c>

      <c>space_total</c>
      <c>44</c>
      <c>uint64</c>
      <c>READ</c>
      <c>
        Total disk space in bytes on the filesystem containing
        this object.
      </c>

      <c>space_used</c>
      <c>45</c>
      <c>uint64</c>
      <c>READ</c>
      <c>
        Number of filesystem bytes allocated to this object.
      </c>

      <c>system</c>
      <c>46</c>
      <c>bool</c>
      <c>R/W</c>
      <c>
        True, if this file is a "system" file with respect to the
        Windows API.
      </c>

      <c>time_access</c>
      <c>47</c>
      <c>nfstime4</c>
      <c>READ</c>
      <c>
        The time of last access to the object by a read that was
        satisfied by the server.
      </c>

      <c>time_access_set</c>
      <c>48</c>
      <c>settime4</c>
      <c>WRITE</c>
      <c>
        Set the time of last access to the object.  SETATTR use only.
      </c>

      <c>time_backup</c>
      <c>49</c>
      <c>nfstime4</c>
      <c>R/W</c>
      <c>
        The time of last backup of the object.
      </c>

      <c>time_create</c>
      <c>50</c>
      <c>nfstime4</c>
      <c>R/W</c>
      <c>
        The time of creation of the object.  This attribute does
        not have any relation to the traditional UNIX file attribute
        "ctime" or "change time".
      </c>

      <c>time_delta</c>
      <c>51</c>
      <c>nfstime4</c>
      <c>READ</c>
      <c>
        Smallest useful server time granularity.
      </c>

      <c>time_metadata</c>
      <c>52</c>
      <c>nfstime4</c>
      <c>READ</c>
      <c>
        The time of last meta-data modification of the object.
      </c>

      <c>time_modify</c>
      <c>53</c>
      <c>nfstime4</c>
      <c>READ</c>
      <c>
        The time of last modification to the object.
      </c>

      <c>time_modify_set</c>
      <c>54</c>
      <c>settime4</c>
      <c>WRITE</c>
      <c>
        Set the time of last modification to the object.  SETATTR use
        only.
      </c>

      <c>mounted_on_fileid</c>
      <c>55</c>
      <c>uint64</c>
      <c>READ</c>
      <c>
        Like fileid, but if the target filehandle is the root of a
        filesystem return the fileid of the underlying directory.
      </c>
    </texttable>

  </section>
  <section title="Time Access">

    <t>
      As defined above, the time_access attribute represents
      the time of last access to the object by a read that was
      satisfied by the server.  The notion of what is an "access"
      depends on server's operating environment and/or the server's
      filesystem semantics.  For example, for servers obeying POSIX
      semantics, time_access would be updated only by the READLINK,
      READ, and READDIR operations and not any of the operations
      that modify the content of the object.  Of course, setting the
      corresponding time_access_set attribute is another way to modify
      the time_access attribute.
    </t>

    <t>
      Whenever the file object resides on a writable filesystem,
      the server should make best efforts to record time_access
      into stable storage.  However, to mitigate the performance
      effects of doing so, and most especially whenever the server
      is satisfying the read of the object's content from its cache,
      the server MAY cache access time updates and lazily write them
      to stable storage.  It is also acceptable to give administrators
      of the server the option to disable time_access updates.
    </t>

  </section>
  <section title="Interpreting owner and owner_group">

    <t>
      The recommended attributes "owner" and "owner_group" (and also
      users and groups within the "acl" attribute) are represented
      in terms of a UTF-8 string.  To avoid a representation that
      is tied to a particular underlying implementation at the
      client or server, the use of the UTF-8 string has been chosen.
      Note that section 6.1 of <xref target="RFC2624" /> provides additional rationale.
      It is expected that the client and server will have their own
      local representation of owner and owner_group that is used for
      local storage or presentation to the end user.  Therefore,
      it is expected that when these attributes are transferred
      between the client and server that the local representation
      is translated to a syntax of the form "user@dns_domain".
      This will allow for a client and server that do not use the
      same local representation the ability to translate to a common
      syntax that can be interpreted by both.
    </t>

    <t>
      Similarly, security principals may be represented in different
      ways by different security mechanisms.  Servers normally
      translate these representations into a common format, generally
      that used by local storage, to serve as a means of identifying
      the users corresponding to these security principals.  When these
      local identifiers are translated to the form of the owner
      attribute, associated with files created by such principals
      they identify, in a common format, the users associated with
      each corresponding set of security principals.
    </t>

    <t>
      The translation used to interpret owner and group strings is
      not specified as part of the protocol.  This allows various
      solutions to be employed.  For example, a local translation
      table may be consulted that maps between a numeric id to the
      user@dns_domain syntax.  A name service may also be used to
      accomplish the translation.  A server may provide a more general
      service, not limited by any particular translation (which would
      only translate a limited set of possible strings) by storing the
      owner and owner_group attributes in local storage without any
      translation or it may augment a translation method by storing
      the entire string for attributes for which no translation is
      available while using the local representation for those cases
      in which a translation is available.
    </t>

    <t>
      Servers that do not provide support for all possible values of
      the owner and owner_group attributes, should return an error
      (NFS4ERR_BADOWNER) when a string is presented that has no
      translation, as the value to be set for a SETATTR of the owner,
      owner_group, or acl attributes.  When a server does accept an
      owner or owner_group value as valid on a SETATTR (and similarly
      for the owner and group strings in an acl), it is promising to
      return that same string when a corresponding GETATTR is done.
      Configuration changes and ill-constructed name translations
      (those that contain aliasing) may make that promise impossible
      to honor.  Servers should make appropriate efforts to avoid a
      situation in which these attributes have their values changed
      when no real change to ownership has occurred.
    </t>

    <t>
      The "dns_domain" portion of the owner string is meant to be a DNS
      domain name.  For example, user@ietf.org.  Servers should accept
      as valid a set of users for at least one domain.  A server
      may treat other domains as having no valid translations.
      A more general service is provided when a server is capable
      of accepting users for multiple domains, or for all domains,
      subject to security constraints.
    </t>

    <t>
      In the case where there is no translation available to the
      client or server, the attribute value must be constructed
      without the "@".  Therefore, the absence of the @ from the
      owner or owner_group attribute signifies that no translation was
      available at the sender and that the receiver of the attribute
      should not use that string as a basis for translation into its
      own internal format.  Even though the attribute value can not
      be translated, it may still be useful.  In the case of a client,
      the attribute string may be used for local display of ownership.
    </t>

    <t>
      To provide a greater degree of compatibility with previous
      versions of NFS (i.e., v2 and v3), which identified users and
      groups by 32-bit unsigned uid's and gid's, owner and group
      strings that consist of decimal numeric values with no leading
      zeros can be given a special interpretation by clients and
      servers which choose to provide such support.  The receiver
      may treat such a user or group string as representing the same
      user as would be represented by a v2/v3 uid or gid having
      the corresponding numeric value.  A server is not obligated
      to accept such a string, but may return an NFS4ERR_BADOWNER
      instead.  To avoid this mechanism being used to subvert user
      and group translation, so that a client might pass all of the
      owners and groups in numeric form, a server SHOULD return an
      NFS4ERR_BADOWNER error when there is a valid translation for
      the user or owner designated in this way.  In that case, the
      client must use the appropriate name@domain string and not the
      special form for compatibility.
    </t>

    <t>
      The owner string "nobody" may be used to designate an anonymous
      user, which will be associated with a file created by a security
      principal that cannot be mapped through normal means to the
      owner attribute.
    </t>

  </section>
  <section title="Character Case Attributes">

    <t>
      With respect to the case_insensitive and case_preserving
      attributes, each UCS-4 character (which UTF-8 encodes) has a
      "long descriptive name" <xref target="RFC1345" /> which may or may not included
      the word "CAPITAL" or "SMALL".  The presence of SMALL or CAPITAL
      allows an NFS server to implement unambiguous and efficient
      table driven mappings for case insensitive comparisons,
      and non-case-preserving storage.  For general character
      handling and internationalization issues, see <xref target="sec:intro" />
      "Internationalization".
    </t>

  </section>
  <section anchor="ss:at:qa" title="Quota Attributes">

    <t>
      For the attributes related to filesystem quotas, the following
      definitions apply:

      <list style='hanging'>
         <t hangText="quota_avail_soft">
           The value in bytes which represents the amount of additional
           disk space that can be allocated to this file or directory
           before the user may reasonably be warned.  It is understood
           that this space may be consumed by allocations to other
           files or directories though there is a rule as to which
           other files or directories.
         </t>

         <t hangText="quota_avail_hard">
           The value in bytes which represent the amount of
           additional disk space beyond the current allocation that
           can be allocated to this file or directory before further
           allocations will be refused.  It is understood that this
           space may be consumed by allocations to other files or
           directories.
         </t>

         <t hangText="quota_used">
           The value in bytes which represent the amount of disc
           space used by this file or directory and possibly a number
           of other similar files or directories, where the set of
           "similar" meets at least the criterion that allocating
           space to any file or directory in the set will reduce the
           "quota_avail_hard" of every other file or directory in
           the set.
         <vspace blankLines='1' />
           Note that there may be a number of distinct but overlapping
           sets of files or directories for which a quota_used value
           is maintained (e.g., "all files with a given owner",
           "all files with a given group owner", etc.).
         <vspace blankLines='1' />
           The server is at liberty to choose any of those sets
           but should do so in a repeatable way.  The rule may be
           configured per-filesystem or may be "choose the set with
           the smallest quota".
         </t>
      </list>
    </t>

  </section>
  <section title="Access Control Lists">

    <t>
      The NFS version 4 ACL attribute is an array of access control
      entries (ACE).  Although, the client can read and write the
      ACL attribute, the NFSv4 model is the server does all access
      control based on the server's interpretation of the ACL.  If at
      any point the client wants to check access without issuing an
      operation that modifies or reads data or metadata, the client
      can use the OPEN and ACCESS operations to do so.  There are
      various access control entry types, as defined in the Section
      "ACE type".  The server is able to communicate which ACE types
      are supported by returning the appropriate value within the
      aclsupport attribute.  Each ACE covers one or more operations
      on a file or directory as described in the Section "ACE Access
      Mask".  It may also contain one or more flags that modify the
      semantics of the ACE as defined in the Section "ACE flag".
    </t>

    <t>
      The NFS ACE attribute is defined as follows:

      <?rfc include='autogen/type_acetype4.xml'?>
      <?rfc include='autogen/type_aceflag4.xml'?>
      <?rfc include='autogen/type_acemask4.xml'?>

      <?rfc include='autogen/type_nfsace4.xml'?>
    </t>

    <t>
      To determine if a request succeeds, each nfsace4 entry is
      processed in order by the server.  Only ACEs which have a
      "who" that matches the requester are considered.  Each ACE is
      processed until all of the bits of the requester's access have
      been ALLOWED.  Once a bit (see below) has been ALLOWED by an
      ACCESS_ALLOWED_ACE, it is no longer considered in the processing
      of later ACEs.  If an ACCESS_DENIED_ACE is encountered where
      the requester's access still has unALLOWED bits in common with
      the "access_mask" of the ACE, the request is denied.  However,
      unlike the ALLOWED and DENIED ACE types, the ALARM and AUDIT ACE
      types do not affect a requester's access, and instead are for
      triggering events as a result of a requester's access attempt.
    </t>

    <t>
      Therefore, all AUDIT and ALARM ACEs are processed until end of
      the ACL.  When the ACL is fully processed, if there are bits
      in requester's mask that have not been considered whether the
      server allows or denies the access is undefined.  If there is
      a mode attribute on the file, then this cannot happen, since
      the mode's MODE4_*OTH bits will map to EVERYONE@ ACEs that
      unambiguously specify the requester's access.
    </t>

    <t>
      The NFS version 4 ACL model is quite rich.  Some server platforms
      may provide access control functionality that goes beyond the
      UNIX-style mode attribute, but which is not as rich as the
      NFS ACL model.  So that users can take advantage of this more
      limited functionality, the server may indicate that it supports
      ACLs as long as it follows the guidelines for mapping between
      its ACL model and the NFS version 4 ACL model.
    </t>

    <t>
      The situation is complicated by the fact that a server may
      have multiple modules that enforce ACLs.  For example, the
      enforcement for NFS version 4 access may be different from the
      enforcement for local access, and both may be different from
      the enforcement for access through other protocols such as SMB.
      So it may be useful for a server to accept an ACL even if not
      all of its modules are able to support it.
    </t>

    <t>
      The guiding principle in all cases is that the server must not
      accept ACLs that appear to make the file more secure than it
      really is.
    </t>

    <section title="ACE type">

      <texttable anchor="ace_type_tbl">
        <ttcol align='left' >Type</ttcol>
        <ttcol align='left' >Description</ttcol>
          <c>ALLOW</c>
          <c>
             Explicitly grants the access defined in acemask4 to the
             file or directory.
          </c>

          <c>DENY</c>
          <c>
             Explicitly denies the access defined in acemask4 to the
             file or directory.
          </c>

          <c>AUDIT</c>
          <c>
             LOG (system dependent) any access attempt to a file or
             directory which uses any of the access methods specified
             in acemask4.
          </c>

          <c>ALARM</c>
          <c>
             Generate a system ALARM (system dependent) when any access
             attempt is made to a file or directory for the access
             methods specified in acemask4.
          </c>
       </texttable>

      <t>
        A server need not support all of the above ACE types.
        The bitmask constants used to represent the above definitions
        within the aclsupport attribute are as follows:

        <?rfc include='autogen/const_aclsupport4.xml'?>
      </t>

      <t>
        The semantics of the "type" field follow the descriptions
        provided above.
      </t>

      <t>
        The constants used for the type field (acetype4) are as follows:

        <?rfc include='autogen/const_acetype4.xml'?>
      </t>

      <t>
        Clients should not attempt to set an ACE unless the server
        claims support for that ACE type.  If the server receives a
        request to set an ACE that it cannot store, it MUST reject
        the request with NFS4ERR_ATTRNOTSUPP.  If the server receives
        a request to set an ACE that it can store but cannot enforce,
        the server SHOULD reject the request with NFS4ERR_ATTRNOTSUPP.
      </t>

      <t>
        Example: suppose a server can enforce NFS ACLs for NFS access but
        cannot enforce ACLs for local access.  If arbitrary processes
        can run on the server, then the server SHOULD NOT indicate
        ACL support.  On the other hand, if only trusted administrative
        programs run locally, then the server may indicate ACL support.
      </t>

    </section>
    <section title="ACE Access Mask">

      <t>
        The access_mask field contains values based on the following:
      </t>

      <texttable anchor="ace_access_tbl">
        <ttcol align='left' >Access</ttcol>
        <ttcol align='left' >Description</ttcol>

        <c>READ_DATA</c>
        <c>
          Permission to read the data of the file
        </c>

        <c>LIST_DIRECTORY</c>
        <c>
          Permission to list the contents of a directory
        </c>

        <c>WRITE_DATA</c>
        <c>
          Permission to modify the file's data
        </c>

        <c>ADD_FILE</c>
        <c>
          Permission to add a new file to a directory
        </c>

        <c>APPEND_DATA</c>
        <c>
          Permission to append data to a file
        </c>

        <c>ADD_SUBDIRECTORY</c>
        <c>
          Permission to create a subdirectory to a directory
        </c>

        <c>READ_NAMED_ATTRS</c>
        <c>
          Permission to read the named attributes of a file
        </c>

        <c>WRITE_NAMED_ATTRS</c>
        <c>
          Permission to write the named attributes of a file
        </c>

        <c>EXECUTE</c>
        <c>
          Permission to execute a file
        </c>

        <c>DELETE_CHILD</c>
        <c>
          Permission to delete a file or directory within a directory
        </c>

        <c>READ_ATTRIBUTES</c>
        <c>
          The ability to read basic attributes (non-acls) of a file
        </c>

        <c>WRITE_ATTRIBUTES</c>
        <c>
          Permission to change basic attributes (non-acls) of a file
        </c>

        <c>DELETE</c>
        <c>
          Permission to Delete the file
        </c>

        <c>READ_ACL</c>
        <c>
          Permission to Read the ACL
        </c>

        <c>WRITE_ACL</c>
        <c>
          Permission to Write the ACL
        </c>

        <c>WRITE_OWNER</c>
        <c>
          Permission to change the owner
        </c>

        <c>SYNCHRONIZE</c>
        <c>
          Permission to access file locally at the server with
          synchronous reads and writes
        </c>
      </texttable>

      <t>
        The bitmask constants used for the access mask field are
        as follows:

        <?rfc include='autogen/const_acemask4.xml'?>
      </t>

      <t>
        Server implementations need not provide the granularity of
        control that is implied by this list of masks.  For example,
        POSIX-based systems might not distinguish APPEND_DATA (the
        ability to append to a file) from WRITE_DATA (the ability to
        modify existing contents); both masks would be tied to a single
        "write" permission.  When such a server returns attributes to
        the client, it would show both APPEND_DATA and WRITE_DATA if
        and only if the write permission is enabled.
      </t>

      <t>
        If a server receives a SETATTR request that it cannot accurately
        implement, it should error in the direction of more restricted
        access.  For example, suppose a server cannot distinguish
        overwriting data from appending new data, as described in the
        previous paragraph.  If a client submits an ACE where APPEND_DATA
        is set but WRITE_DATA is not (or vice versa), the server should
        reject the request with NFS4ERR_ATTRNOTSUPP.  Nonetheless,
        if the ACE has type DENY, the server may silently turn on the
        other bit, so that both APPEND_DATA and WRITE_DATA are denied.
      </t>

    </section>
    <section title="ACE flag">

      <t>
        The "flag" field contains values based on the following
        descriptions.

        <list style='hanging'>
          <t hangText="ACE4_FILE_INHERIT_ACE">
            Can be placed on a directory and indicates that this ACE
            should be added to each new non-directory file created.
          </t>

          <t hangText="ACE4_DIRECTORY_INHERIT_ACE">
            Can be placed on a directory and indicates that this ACE
            should be added to each new directory created.
          </t>

          <t hangText="ACE4_INHERIT_ONLY_ACE">
            Can be placed on a directory but does not apply to the
            directory, only to newly created files/directories as
            specified by the above two flags.
          </t>

          <t hangText="ACE4_NO_PROPAGATE_INHERIT_ACE">
            Can be placed on a directory.  Normally when a new
            directory is created and an ACE exists on the parent
            directory which is marked ACL4_DIRECTORY_INHERIT_ACE,
            two ACEs are placed on the new directory.  One for the
            directory itself and one which is an inheritable ACE for
            newly created directories.  This flag tells the server
            to not place an ACE on the newly created directory which
            is inheritable by subdirectories of the created directory.
          </t>

          <t hangText="ACE4_SUCCESSFUL_ACCESS_ACE_FLAG">
          </t>

          <t hangText="ACL4_FAILED_ACCESS_ACE_FLAG">
            The ACE4_SUCCESSFUL_ACCESS_ACE_FLAG (SUCCESS)
            and ACE4_FAILED_ACCESS_ACE_FLAG (FAILED) flag bits
            relate only to ACE4_SYSTEM_AUDIT_ACE_TYPE (AUDIT) and
            ACE4_SYSTEM_ALARM_ACE_TYPE (ALARM) ACE types.  If during
            the processing of the file's ACL, the server encounters an
            AUDIT or ALARM ACE that matches the principal attempting
            the OPEN, the server notes that fact, and the presence,
            if any, of the SUCCESS and FAILED flags encountered in
            the AUDIT or ALARM ACE.  Once the server completes the ACL
            processing, and the share reservation processing, and the
            OPEN call, it then notes if the OPEN succeeded or failed.
            If the OPEN succeeded, and if the SUCCESS flag was set for
            a matching AUDIT or ALARM, then the appropriate AUDIT or
            ALARM event occurs.  If the OPEN failed, and if the FAILED
            flag was set for the matching AUDIT or ALARM, then the
            appropriate AUDIT or ALARM event occurs.  Clearly either or
            both of the SUCCESS or FAILED can be set, but if neither
            is set, the AUDIT or ALARM ACE is not useful.
          <vspace blankLines='1' />
            The previously described processing applies to that of
            the ACCESS operation as well.  The difference being that
            "success" or "failure" does not mean whether ACCESS returns
            NFS4_OK or not.  Success means whether ACCESS returns all
            requested and supported bits.  Failure means whether ACCESS
            failed to return a bit that was requested and supported.
          </t>

          <t hangText="ACE4_IDENTIFIER_GROUP">
            Indicates that the "who" refers to a GROUP as defined
            under UNIX.
          </t>
        </list>
      </t>

      <t>
        The bitmask constants used for the flag field are as follows:

        <?rfc include='autogen/const_aceflag4.xml'?>
      </t>

      <t>
        A server need not support any of these flags.  If the server
        supports flags that are similar to, but not exactly the same as,
        these flags, the implementation may define a mapping between
        the protocol-defined flags and the implementation-defined flags.
        Again, the guiding principle is that the file not appear to be
        more secure than it really is.
      </t>

      <t>
        For example, suppose a client tries to set an ACE with
        ACE4_FILE_INHERIT_ACE set but not ACE4_DIRECTORY_INHERIT_ACE.
        If the server does not support any form of ACL inheritance,
        the server should reject the request with NFS4ERR_ATTRNOTSUPP.
        If the server supports a single "inherit ACE" flag that applies
        to both files and directories, the server may reject the request
        (i.e., requiring the client to set both the file and directory
        inheritance flags).  The server may also accept the request
        and silently turn on the ACE4_DIRECTORY_INHERIT_ACE flag.
      </t>

    </section>
    <section title="ACE who">

      <t>
        There are several special identifiers ("who") which need to
        be understood universally, rather than in the context of a
        particular DNS domain.  Some of these identifiers cannot be
        understood when an NFS client accesses the server, but have
        meaning when a local process accesses the file.  The ability
        to display and modify these permissions is permitted over NFS,
        even if none of the access methods on the server understands
        the identifiers.
      </t>

      <texttable anchor="ace_who_tbl">
        <ttcol align='left' >Who</ttcol>
        <ttcol align='left' >Description</ttcol>

        <c>"OWNER"</c>
        <c>
          The owner of the file.
        </c>
   
        <c>"GROUP"</c>
        <c>
          The group associated with the file.
        </c>
   
        <c>"EVERYONE"</c>
        <c>
          The world.
        </c>
   
        <c>"INTERACTIVE"</c>
        <c>
          Accessed from an interactive terminal.
        </c>
   
        <c>"NETWORK"</c>
        <c>
          Accessed via the network.
        </c>
   
        <c>"DIALUP"</c>
        <c>
          Accessed as a dialup user to the server.
        </c>
   
        <c>"BATCH"</c>
        <c>
          Accessed from a batch job.
        </c>
   
        <c>"ANONYMOUS"</c>
        <c>
          Accessed without any authentication.
        </c>
   
        <c>"AUTHENTICATED"</c>
        <c>
          Any authenticated user (opposite of ANONYMOUS)
        </c>
   
        <c>"SERVICE"</c>
        <c>
          Access from a system service.
        </c>

      </texttable>

      <t>
        To avoid conflict, these special identifiers are distinguish
        by an appended "@" and should appear in the form "xxxx@"
       (note: no domain name after the "@").  For example: ANONYMOUS@.
      </t>

    </section>
    <section title="Mode Attribute">

      <t>
        The NFS version 4 mode attribute is based on the UNIX mode bits.
        The following bits are defined:

        <?rfc include='autogen/const_mode4.xml'?>
      </t>

      <t>
        Bits MODE4_RUSR, MODE4_WUSR, and MODE4_XUSR apply to the
        principal identified in the owner attribute.  Bits MODE4_RGRP,
        MODE4_WGRP, and MODE4_XGRP apply to the principals identified
        in the owner_group attribute.  Bits MODE4_ROTH, MODE4_WOTH,
        MODE4_XOTH apply to any principal that does not match that in
        the owner group, and does not have a group matching that of
        the owner_group attribute.
      </t>

      <t>
        The remaining bits are not defined by this protocol and MUST
        NOT be used.  The minor version mechanism must be used to define
        further bit usage.
      </t>

      <t>
        Note that in UNIX, if a file has the MODE4_SGID bit set and
        no MODE4_XGRP bit set, then READ and WRITE must use mandatory
        file locking.
      </t>

    </section>
    <section title="Mode and ACL Attribute">

      <t>
        The server that supports both mode and ACL must take care to
        synchronize the MODE4_*USR, MODE4_*GRP, and MODE4_*OTH bits
        with the ACEs which have respective who fields of "OWNER@",
        "GROUP@", and "EVERYONE@" so that the client can see semantically
        equivalent access permissions exist whether the client asks
        for owner, owner_group and mode attributes, or for just the ACL.
      </t>

      <t>
        Because the mode attribute includes bits (e.g., MODE4_SVTX)
        that have nothing to do with ACL semantics, it is permitted for
        clients to specify both the ACL attribute and mode in the same
        SETATTR operation.  However, because there is no prescribed
        order for processing the attributes in a SETATTR, the client
        must ensure that ACL attribute, if specified without mode,
        would produce the desired mode bits, and conversely, the mode
        attribute if specified without ACL, would produce the desired
        "OWNER@", "GROUP@", and "EVERYONE@" ACEs.
      </t>

    </section>
    <section title="mounted_on_fileid">

      <t>
        UNIX-based operating environments connect a filesystem into
        the namespace by connecting (mounting) the filesystem onto the
        existing file object (the mount point, usually a directory)
        of an existing filesystem.  When the mount point's parent
        directory is read via an API like readdir(), the return results
        are directory entries, each with a component name and a fileid.
        The fileid of the mount point's directory entry will be different
        from the fileid that the stat() system call returns.  The stat()
        system call is returning the fileid of the root of the mounted
        filesystem, whereas readdir() is returning the fileid stat()
        would have returned before any filesystems were mounted on the
        mount point.
      </t>

      <t>
        Unlike NFS version 3, NFS version 4 allows a client's LOOKUP
        request to cross other filesystems.  The client detects the
        filesystem crossing whenever the filehandle argument of LOOKUP
        has an fsid attribute different from that of the filehandle
        returned by LOOKUP.  A UNIX-based client will consider
        this a "mount point crossing".  UNIX has a legacy scheme for
        allowing a process to determine its current working directory.
        This relies on readdir() of a mount point's parent and stat()
        of the mount point returning fileids as previously described.
        The mounted_on_fileid attribute corresponds to the fileid that
        readdir() would have returned as described previously.
      </t>

      <t>
        While the NFS version 4 client could simply fabricate a fileid
        corresponding to what mounted_on_fileid provides (and if the
        server does not support mounted_on_fileid, the client has no
        choice), there is a risk that the client will generate a fileid
        that conflicts with one that is already assigned to another
        object in the filesystem.  Instead, if the server can provide
        the mounted_on_fileid, the potential for client operational
        problems in this area is eliminated.
      </t>

      <t>
        If the server detects that there is no mounted point at the
        target file object, then the value for mounted_on_fileid that
        it returns is the same as that of the fileid attribute.
      </t>

      <t>
        The mounted_on_fileid attribute is RECOMMENDED, so the server
        SHOULD provide it if possible, and for a UNIX-based server, this
        is straightforward.  Usually, mounted_on_fileid will be requested
        during a READDIR operation, in which case it is trivial (at least
        for UNIX-based servers) to return mounted_on_fileid since it is
        equal to the fileid of a directory entry returned by readdir().
        If mounted_on_fileid is requested in a GETATTR operation,
        the server should obey an invariant that has it returning a
        value that is equal to the file object's entry in the object's
        parent directory, i.e., what readdir() would have returned.
        Some operating environments allow a series of two or more
        filesystems to be mounted onto a single mount point.  In this
        case, for the server to obey the aforementioned invariant, it
        will need to find the base mount point, and not the intermediate
        mount points.
      </t>

    </section>
  </section>
</section>
